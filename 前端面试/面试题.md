### 1.闭包（closure）
示例：
```javascript
function createCounter() {

  let count = 0;

  return function () {

    return ++count;

  };

}

const counter = createCounter();

console.log(counter());// 1
console.log(counter());// 2
console.log(counter());// 3
```
#### 为什么闭包有助于数据封装？
	 因为它允许创建私有的变量和函数，这些变量和函数只能通过闭包内的特定代码访问，外部无法直接访问或修改它们。这种特性使闭包实现数据隐藏和保护的强大工具。
	 原因：
> 	1. 作用域隔离：闭包在定义时保存了创建时的词法作用域，因此可以在外部作用域内维持变量的访问权限。这意味着变量可以被函数保持在一个私有的作用域中，防止其他代码访问或修改。
> 	2.  持久化数据：闭包允许在执行后仍然保持其创建时的环境，即使外部函数已经被调用结束。这样，内部函数仍可以访问和操作该环境中的变量，从而实现持久化的数据存储。
> 	3. 数据保护：通过将变量封装在闭包中，外部作用域无法直接访问或修改这些变量。只有通过闭包提供的接口函数（如返回的函数）才能简介访问和修改这些变量，从而保护数据不被外部意外篡改。

示例：
```javascript
 function createCounter() {
    let count = 0; // 私有变量，外部无法直接访问

    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 输出: 1
console.log(counter.increment()); // 输出: 2
console.log(counter.getCount());  // 输出: 2
console.log(counter.count);       // 输出: undefined (无法访问私有变量)
```
在这个例子中，`count` 是 `createCounter` 内部定义的私有变量，只能通过 `increment`、`decrement` 和 `getCount` 访问，而无法直接在外部修改或读取。这种封装提高了代码的安全性和模块化，使得数据只能通过受控的方式进行访问和修改。
#### 如何避免闭包引起的内存泄漏？
##### 1.避免不必要的全局引用
- 闭包会保留其父作用域的引用。如果这些引用保留了不需要的全局对象或大量的数据，会导致内存无法被释放。应该避免在闭包中对全局变量的引用，或者使用后及时清理这些引用。
##### 2.使用弱引用
- 在某些高级JavaScript环境中（如使用`WeakMap`)，弱引用的对象不会阻止垃圾回收，这有助于避免内存泄漏。使用`WeakMap`存储对象时，当对象不再被引用时，他们会自动被回收。
##### 3.及时解除引用
- 当闭包中的数据不再需要时，可以通过设置引用为`null`或`undefined`来手动解除引用。例如:
```javascript
function createFunction() {
    let data = "This is some data";
    return function() {
        console.log(data);
    };
}

let closureFunction = createFunction();
closureFunction = null; // 手动解除引用，允许垃圾回收
```
##### 4.避免在长周期对象上使用闭包
- 在时间监听器、定时器或回调函数中使用闭包时，如果这些对象的生命周期较长，可能会导致内存泄漏。应在不需要时使用适当的方法解除这些绑定或清理闭包。例如：
```javascript
function attachListener() {
    let element = document.getElementById("myButton");
    element.addEventListener("click", function() {
        console.log("Button clicked!");
    });

    // 解除事件监听器，避免闭包引起的内存泄漏
    return function cleanup() {
        element.removeEventListener("click", arguments.callee);
    };
}

let cleanupFunction = attachListener();
// 在合适的时候调用 cleanupFunction() 以清理闭包
```
##### 5.谨慎使用DOM引用
- 如果闭包保留了对DOM元素的引用，而这些元素已经被移除或不再需要，这可能会导致内存泄露。在删除DOM元素时，确保相关的闭包不会再引用这些元素。
```javascript
function setup() {
    let element = document.getElementById("myElement");
    element.someProperty = function() {
        console.log("This is a closure");
    };

    // 清理闭包对 DOM 的引用
    element.someProperty = null;
}
```
##### 6.使用开发者工具检测
- 使用浏览器工具，如 chrome devtools 的内存面板，检测和分析内存快照，查找闭包相关的内存泄漏，它可以帮助识别哪些对象未被正确回收。
# 2.Vue
#### 1.Vue生命周期
Vue生命周期分为四个阶段：创建、挂载、更新和销毁。
1. 创建阶段：分为`beforeCreate`和`created`。在这期间，实力初始化完成，可以访问data与methods，DOM还没有挂载完成。
2. 挂载阶段：分为`beforeMounte`和`mounted`。在这期间，虚拟DOM挂载完成，`mounted`后可以操作真实DOM。
3. 更新阶段：分为`beforeUpdate`和`updated`。在这期间，数据发生变化，组件会重新渲染。
4. 销毁阶段：分为`beforeDestroy`和`destroyed`。在这期间，组件会从页面卸载，清理定时器、事件监听等。
我们经常在`mounted`初始化数据，在`beforeDestroy`来清理资源。
#### 2. 组件间通信
1. 父子组件间通信：通过`props`向子组件传递数据，子组件通过`$emit`绑定事件通知父组件。
2. 兄弟组件间通信：通过`EventBus`实现，或者使用`vuex`这样的状态管理工具。
3. 跨层级通信：通过`provide/inject`来实现祖先和后代组件间通信。
4. 全局状态管理：使用`Vuex`或者`Pinia`管理全局共享状态，适合复杂场景。
实际项目中，根据需求选择最合适的通信方式，确保代码清晰且易于维护。
#### 3. 性能优化
1. 代码层面：减少DOM操作，优化事件绑定，使用防抖和节流。
2. 资源优化：压缩CSS/JS文件，使用Tree Shaking去除无用代码，开启Gzip压缩。
3. 加载优化：使用懒加载、骨架屏，分离首屏和次屏资源。
4. 网络优化：使用CDN加速，和并请求，开启HTTP/2。
5. 渲染优化：通过虚拟列表优化长列表渲染，尽量避免全局样式污染。
#### 4.跨域
1. CORS：服务器端设置允许的源和方法，最常用的方式。
2. JSONP：通过`script`标签请求实现，只支持GET请求。
3. 代理：通过前端发代理服务器转发请求，解决跨域问题。
4. WebScoket：它不受同源策略的限制，可用于跨域通信。
# 3.UniApp
#### 1.简介
UniApp 是一个使用 Vue 语法编写小程序、H5 和 App 的多端开发框架。它的核心特点是一次开发，多端运行，支持微信小程序、支付宝小程序、H5、App 等多种平台。  
**优势主要有以下几点：**
1. **跨平台开发**：一套代码支持多端，降低了开发成本。
2. **高性能**：通过原生渲染优化性能表现，尤其在 App 和小程序中表现优秀。
3. **丰富的生态**：支持各种插件和扩展，开发效率高。
4. **开发体验**：与 Vue 语法一致，学习成本低，并支持灵活的组件化开发。  
#### 2.运行原理
UniApp 是基于 Vue.js 实现的跨端框架，采用了**编译器模式**来实现跨平台支持。
1. **代码分发**：开发者通过 Vue 语法编写代码，UniApp 的编译器会根据不同平台生成相应的目标代码，比如微信小程序代码或原生 App 代码。
2. **渲染机制**：小程序端和 App 端通过原生渲染提高性能，H5 端则使用 DOM 渲染。
3. **API 适配**：UniApp 提供了丰富的跨端 API，比如网络请求、文件操作等，通过平台特定的 API 适配层实现统一调用。  
    因此，开发者不需要关注平台差异，极大提升了开发效率。
#### 3.小程序和 H5 的适配问题
UniApp 提供了 **平台判定** 和 **条件编译** 来处理不同平台的差异：

1. **平台判定**：使用 `uni.getSystemInfoSync().platform` 获取运行平台信息，动态处理不同逻辑。
2. **条件编译**：通过 `#ifdef` 和 `#ifndef` 指令，在不同平台编译不同代码。例如：
```javascript
// #ifdef H5
console.log('这是 H5 平台');
// #endif

// #ifdef MP-WEIXIN
console.log('这是微信小程序平台');
// #endif
```
#### 4.页面跳转
UniApp 提供了多种跳转方法，常用的包括：

1. **`navigateTo`**：跳转到非 Tab 页面，但无法返回。
2. **`redirectTo`**：跳转到非 Tab 页面，会关闭当前页面。
3. **`switchTab`**：切换到 Tab 页面，不能传递参数。
4. **`reLaunch`**：关闭所有页面并跳转。
5. **`navigateBack`**：返回上一级页面。  
#### 5.数据存储
UniApp 提供了多种数据存储方式：

1. **本地存储**：通过 `uni.setStorage` 和 `uni.getStorage` 操作小型数据。
```javascript
uni.setStorage({
  key: 'userInfo',
  data: { name: '张三' }
});
uni.getStorage({
  key: 'userInfo',
  success: (res) => {
    console.log(res.data);
  }
});
```
2. **全局变量**：可以通过 `App.vue` 中的全局变量保存运行中的数据。
3. **状态管理**：使用 Vuex 或 Pinia 管理全局状态，适合复杂场景。
4. **数据库**：如果需要存储大数据，可以结合后端数据库或本地 SQLite。  
    我在项目中经常使用本地存储保存用户偏好设置，同时通过 Vuex 管理用户登录状态。
#### 6.uni.request的使用
UniApp 提供了 `uni.request` 方法，用于发起网络请求，支持 GET 和 POST 请求。例如：
```javascript
uni.request({
  url: 'https://example.com/api/login',
  method: 'POST',
  data: {
    username: 'test',
    password: '123456'
  },
  success: (res) => {
    console.log('请求成功', res.data);
  },
  fail: (err) => {
    console.error('请求失败', err);
  }
});
```
#### 7.如何封装公共方法？
在 UniApp 中，我会将公共方法封装在 `utils` 文件夹下，并通过 `import` 引入。例如：
```javascript
// utils/request.js
export const request = (url, method, data) => {
  return new Promise((resolve, reject) => {
    uni.request({
      url,
      method,
      data,
      success: resolve,
      fail: reject
    });
  });
};
```
通过封装后，调用网络请求更加便捷，也利于统一管理错误处理。
#### 8.如何优化 UniApp 性能？
UniApp 性能优化可以从以下几个方面入手：
1. **减少页面层级**：避免多层嵌套，使用更扁平化的页面结构。
2. **懒加载**：延迟加载图片和组件，减少首屏加载压力。
3. **分包加载**：将应用划分为多个分包，小程序平台支持分包加载。
4. **精简代码**：去除无用样式和未使用的组件。
5. **事件节流**：对频繁触发的事件（如滚动、输入）添加节流或防抖处理。  
